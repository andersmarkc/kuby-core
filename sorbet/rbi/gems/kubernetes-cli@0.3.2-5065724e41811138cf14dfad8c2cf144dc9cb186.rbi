# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `kubernetes-cli` gem.
# Please instead update this file by running `bin/tapioca gem kubernetes-cli`.

# typed: strong
class KubernetesCLI
  extend T::Sig

  sig { params(kubeconfig_path: ::String, executable: ::String).void }
  def initialize(kubeconfig_path, executable = T.unsafe(nil)); end

  sig { params(block: T.proc.params(cmd: T::Array[::String], last_status: ::Process::Status).void).void }
  def after_execute(&block); end

  sig do
    params(
      type: ::String,
      namespace: ::String,
      name: ::String,
      annotations: T::Hash[::String, ::String],
      overwrite: T::Boolean
    ).void
  end
  def annotate(type, namespace, name, annotations, overwrite: T.unsafe(nil)); end

  sig { returns(::String) }
  def api_resources; end

  sig { params(res: ::KubeDSL::DSLObject, dry_run: T::Boolean).void }
  def apply(res, dry_run: T.unsafe(nil)); end

  sig { params(uri: ::String, dry_run: T::Boolean).void }
  def apply_uri(uri, dry_run: T.unsafe(nil)); end

  sig { params(block: T.proc.params(cmd: T::Array[::String]).void).void }
  def before_execute(&block); end

  sig { returns(::String) }
  def current_context; end

  sig { params(type: ::String, namespace: ::String, name: ::String).void }
  def delete_object(type, namespace, name); end

  sig { params(type: ::String, namespace: T.any(::String, ::Symbol), match_labels: T::Hash[::String, ::String]).void }
  def delete_objects(type, namespace, match_labels = T.unsafe(nil)); end

  sig do
    params(
      container_cmd: T.any(::String, T::Array[::String]),
      namespace: ::String,
      pod: ::String,
      tty: T::Boolean,
      container: T.nilable(::String),
      out_file: T.nilable(::String)
    ).void
  end
  def exec_cmd(container_cmd, namespace, pod, tty = T.unsafe(nil), container = T.unsafe(nil), out_file = T.unsafe(nil)); end

  sig { returns(::String) }
  def executable; end

  sig { params(type: ::String, namespace: ::String, name: ::String).returns(T::Hash[::String, T.untyped]) }
  def get_object(type, namespace, name); end

  sig do
    params(
      type: ::String,
      namespace: T.any(::String, ::Symbol),
      match_labels: T::Hash[::String, ::String]
    ).returns(T::Array[T.untyped])
  end
  def get_objects(type, namespace, match_labels = T.unsafe(nil)); end

  sig { returns(::String) }
  def kubeconfig_path; end

  sig { returns(T.nilable(::Process::Status)) }
  def last_status; end

  sig { params(namespace: ::String, selector: T::Hash[::String, ::String], follow: T::Boolean).void }
  def logtail(namespace, selector, follow: T.unsafe(nil)); end

  sig { params(block: T.proc.params(last_status: ::Process::Status).void).void }
  def on_last_status_failure(&block); end

  sig { params(type: ::String, namespace: ::String, name: ::String, patch_data: ::String, patch_type: ::String).void }
  def patch_object(type, namespace, name, patch_data, patch_type = T.unsafe(nil)); end

  sig { params(namespace: ::String, deployment: ::String).void }
  def restart_deployment(namespace, deployment); end

  sig { params(cmd: T.any(::String, T::Array[::String])).void }
  def run_cmd(cmd); end

  sig { returns(T.any(::IO, ::StringIO)) }
  def stderr; end

  sig { params(new_stderr: T.nilable(T.any(::IO, ::StringIO))).void }
  def stderr=(new_stderr); end

  sig { returns(T.any(::IO, ::StringIO)) }
  def stdout; end

  sig { params(new_stdout: T.nilable(T.any(::IO, ::StringIO))).void }
  def stdout=(new_stdout); end

  sig do
    params(
      container_cmd: T.any(::String, T::Array[::String]),
      namespace: ::String,
      pod: ::String,
      tty: T::Boolean,
      container: T.nilable(::String)
    ).void
  end
  def system_cmd(container_cmd, namespace, pod, tty = T.unsafe(nil), container = T.unsafe(nil)); end

  sig { returns(T::Hash[T.untyped, T.untyped]) }
  def version; end

  sig { params(block: T.proc.params(last_status: ::Process::Status).void).void }
  def with_last_status(&block); end

  sig { params(out: T.any(::IO, ::StringIO), err: T.any(::IO, ::StringIO), block: T.proc.void).void }
  def with_pipes(out = T.unsafe(nil), err = T.unsafe(nil), &block); end

  private

  sig { params(cmd: T::Array[::String]).returns(::String) }
  def backticks(cmd); end

  sig { params(cmd: T::Array[::String]).returns(::String) }
  def backticks_default(cmd); end

  sig { params(cmd: T::Array[::String]).returns(::String) }
  def backticks_open3(cmd); end

  sig { returns(T::Array[::String]) }
  def base_cmd; end

  sig { returns(T::Hash[::String, ::String]) }
  def env; end

  sig { params(cmd: T::Array[::String]).void }
  def execc(cmd); end

  sig { params(status: ::Process::Status).void }
  def last_status=(status); end

  sig do
    params(
      env: T::Hash[::String, ::String],
      cmd: T::Array[::String],
      opts: T::Hash[::Symbol, T.untyped],
      block: T.proc.params(p_stdin: ::IO).void
    ).void
  end
  def open3_w(env, cmd, opts = T.unsafe(nil), &block); end

  sig { params(cmd: T::Array[::String]).void }
  def run_after_callbacks(cmd); end

  sig { params(cmd: T::Array[::String]).void }
  def run_before_callbacks(cmd); end

  sig { params(cmd: T::Array[::String]).void }
  def systemm(cmd); end

  sig { params(cmd: T::Array[::String]).void }
  def systemm_default(cmd); end

  sig { params(cmd: T::Array[::String]).void }
  def systemm_open3(cmd); end
end

KubernetesCLI::AfterCallback = T.type_alias { T.proc.params(cmd: T::Array[::String], last_status: ::Process::Status).void }
class KubernetesCLI::AnnotateResourceError < ::KubernetesCLI::KubernetesError; end
KubernetesCLI::BeforeCallback = T.type_alias { T.proc.params(cmd: T::Array[::String]).void }
class KubernetesCLI::DeleteResourceError < ::KubernetesCLI::KubernetesError; end
class KubernetesCLI::GetResourceError < ::KubernetesCLI::KubernetesError; end
class KubernetesCLI::GetVersionError < ::KubernetesCLI::KubernetesError; end

class KubernetesCLI::InvalidResourceError < ::KubernetesCLI::KubernetesError
  extend T::Sig

  sig { params(args: T.untyped).void }
  def initialize(*args); end

  sig { returns(T.nilable(::KubeDSL::DSLObject)) }
  def resource; end

  sig { params(resource: ::KubeDSL::DSLObject).returns(::KubeDSL::DSLObject) }
  def resource=(resource); end
end

class KubernetesCLI::InvalidResourceUriError < ::KubernetesCLI::KubernetesError
  extend T::Sig

  sig { params(args: T.untyped).void }
  def initialize(*args); end

  sig { returns(T.nilable(::String)) }
  def resource_uri; end

  sig { params(resource_uri: ::String).returns(::String) }
  def resource_uri=(resource_uri); end
end

class KubernetesCLI::KubernetesError < ::StandardError; end
class KubernetesCLI::PatchResourceError < ::KubernetesCLI::KubernetesError; end
KubernetesCLI::STATUS_KEY = T.let(T.unsafe(nil), Symbol)
KubernetesCLI::STDERR_KEY = T.let(T.unsafe(nil), Symbol)
KubernetesCLI::STDOUT_KEY = T.let(T.unsafe(nil), Symbol)
